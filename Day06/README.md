# Day 06

## Улучшение качества обслуживания клиентов

Добавление новой бизнес-функции в нашу модель данных.

## Introduction

- Для написания программ использовалась версия 15.2 PostgreSQL.
- Исходный код писался в DataGrip IDE.

## Contents

1. [Exercise 00](#exercise-00)
2. [Exercise 01](#exercise-01)
3. [Exercise 02](#exercise-02)
4. [Exercise 03](#exercise-03)
5. [Exercise 04](#exercise-04)
6. [Exercise 05](#exercise-05)
7. [Exercise 06](#exercise-06)

## Rules of the day

- Убедитесь, что у вас есть собственная база данных и доступ к ней PostgreSQL.
- Загрузите [скрипт](materials/model.sql) с моделью базы данных здесь и примените его к своей базе данных. **Все изменения, которые были внесены в День 03 в упражнениях 07–13 и День 04 в упражнении 07, должны быть на месте (это похоже на то, как в реальном мире, когда применяется выпуск, и необходимо обеспечить согласованность с данными для новых изменений).**
- Логическое представление предоставленной модели базы данных:

![schema](misc/images/schema.png)


1. **pizzeria** (Таблица с доступными пиццериями)
- поле id - первичный ключ
- поле name - название пиццерий
- поле rating - средний рейтинг пиццерии (от 0 до 5 баллов)
2. **person** (Таблица с людьми, которые любят пиццу)
- поле id - первичный ключ
- поле name - имя человека
- поле age - возраст человека
- поле gender - половая принадлежность человека
- поле address - адрес человека
3. **menu** (Таблица с доступным меню и ценой на конкретную пиццу)
- поле id - первичный ключ
- поле pizzeria_id - внешний ключ от таблицы пиццерий
- поле pizza_name - название пиццы в пиццерии
- поле price - цена конкретной пиццы
4. **person_visits** (Таблица с информацией о посещениях пиццерии)
- поле id - первичный ключ
- поле person_id - внешний ключ от таблицы с людьми
- поле pizzeria_id - внешний ключ от таблицы пиццерий
- поле visit_date - дата (например: 01.01.2022) посещения человека
5. **person_order** (Таблица с информацией о заказах людей)
- поле id - первичный ключ
- поле person_id - внешний ключ от таблицы с людьми
- поле menu_id - внешний ключ от таблицы с меню
- поле order_date - дата (например: 01.01.2022) заказа человека

Посещение человека и заказ человека являются разными сущностями и не содержат никакой корреляции между данными. Например, клиент может находиться в одном ресторане (просто просматривая меню), а в это время сделать заказ в другом по телефону или через мобильное приложение. Или другой случай, просто оказаться дома и снова позвонить с заказом без всяких посещений.

## Exercise 00

- Программа расположена в директории: ex00;
- Файл для сдачи: `day06_ex00.sql`;
- Языки: SQL, DML, DDL.

Наша модель данных была расширена путем включения новой бизнес-функции:
Каждый человек хочет видеть персональную скидку, а каждый бизнес хочет быть ближе для клиентов.

Создана новая реляционная таблица (с заданным именем `person_discounts`) со следующими правилами.
- установлен атрибут id как первичный ключ;
- для атрибутов person_id и pizzeria_id установлены внешние ключи для соответствующих таблиц;
- заданы явные имена для ограничений внешних ключей по шаблону fk_{table_name}_{column_name}, например `fk_person_discounts_person_id`;
— добавлен атрибут скидки для хранения значения скидки в процентах. Значение скидки является числом с плавающей запятой.

## Exercise 01

- Программа расположена в директории: ex01;
- Файл для сдачи: `day06_ex01.sql`;
- Языки: SQL, DML, DDL.

В этом упражнении проводится заполнение таблицы `person_discounts` новыми записями.

Итак, есть таблица `person_order`, в которой хранится история заказов человека. Написан оператор DML (`INSERT INTO ... SELECT ...`), который вставляет новые записи в таблицу `person_discounts` на основе следующих правил:
- взято агрегированное состояние по столбцам person_id и pizzeria_id;
- рассчитана величина персональной скидки по следующему псевдокоду:

    `if “amount of orders” = 1 then
        “discount” = 10.5 
    else if “amount of orders” = 2 then 
        “discount” = 22
    else 
        “discount” = 30`

- чтобы сгенерировать первичный ключ для таблицы `person_discounts`, использовалась конструкцию SQL представленная ниже (эта конструкция взята из области SQL WINDOW FUNCTION).
    
    `... ROW_NUMBER( ) OVER ( ) AS id ...`

## Exercise 02

- Программа расположена в директории: ex02;
- Файл для сдачи: `day06_ex02.sql`;
- Языки: SQL, DML, DDL.

Написан оператор SQL, который возвращает заказы с фактической ценой и ценой с примененной скидкой для каждого человека в соответствующей пиццерии и сортирует по имени человека и названию пиццы. Образец данных результата представлено ниже.

| name | pizza_name | price | discount_price | pizzeria_name | 
| ------ | ------ | ------ | ------ | ------ |
| Andrey | cheese pizza | 800 | 624 | Dominos |
| Andrey | mushroom pizza | 1100 | 858 | Dominos |
| ... | ... | ... | ... | ... |

## Exercise 03

- Программа расположена в директории: ex03;
- Файл для сдачи: `day06_ex03.sql`;
- Языки: SQL, DML, DDL.

Необходимо улучшить согласованность данных с одной стороны и настройку производительности с другой. Для этого создан уникальный индекс с несколькими столбцами (с именем `idx_person_discounts_unique`), который предотвратит дублирование парных значений идентификаторов человека и пиццерии.

Написан оператор SQL, подтверждающий использование индекса (с помощью `EXPLAIN ANALYZE`).
Пример «доказательства» приведен ниже.

    ...
    Index Scan using idx_person_discounts_unique on person_discounts
    ...

## Exercise 04

- Программа расположена в директории: ex04;
- Файл для сдачи: `day06_ex04.sql`;
- Языки: SQL, DML, DDL.

Добавлены следующие правила ограничений для существующих столбцов таблицы `person_discounts`:
- Столбец person_id не должен быть NULL (использовано имя ограничения `ch_nn_person_id`);
- Столбец pizzeria_id не должен иметь значение NULL (использовано имя ограничения `ch_nn_pizzeria_id`);
- Столбец скидки не должен быть NULL (использовано имя ограничения `ch_nn_discount`);
- В столбце скидки по умолчанию должно быть 0 процентов;
- Столбец скидки должен находиться в диапазоне значений от 0 до 100 (использовано имя ограничения `ch_range_discount`).

## Exercise 05

- Программа расположена в директории: ex05;
- Файл для сдачи: `day06_ex05.sql`;
- Языки: SQL, DML, DDL.

Чтобы соответствовать политике управления данными, необходимо добавить комментарии к таблице и ее столбцам. Такая политика была применена к таблице `person_discounts`. 
Добавлены комментарии на английском, объясняющие, какова бизнес-цель таблицы и всех включенных в нее атрибутов.

## Exercise 06

- Программа расположена в директории: ex06;
- Файл для сдачи: `day06_ex06.sql`;
- Языки: SQL, DML, DDL.

**Недопустимо**
- SQL синтаксические паттерны: нельзя использовать жестко запрограммированное значение количества строк, чтобы установить правильное значение для последовательности.

Создана последовательность базы данных с именем `seq_person_discounts` (начиная со значения 1) и установлено значение по умолчанию для атрибута id таблицы `person_discounts`, чтобы каждый раз автоматически брать значение из `seq_person_discounts`.
Имея в виду, что следующий порядковый номер равен 1, в этом случае было установлено фактическое значение для последовательности базы данных на основе формулы «количество строк в таблице `person_discounts`» + 1. В противном случае были бы ошибки о нарушении ограничения первичного ключа.
